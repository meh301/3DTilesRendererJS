import{t as Pt}from"./TilesRenderer-CeXRket9.js";import{P as Ut,T as It}from"./EPSGTilesPlugin-zoCLijLZ.js";import{ba as St,aj as gt,M as Et,g as yt,l as J,ak as st,p as Vt,J as Ct,T as Mt,bb as Nt,w as Bt,i as it,an as pt}from"./three.module-Cdr6prlM.js";import{L as zt}from"./readMagicBytes-B3HEinov.js";import{E as Ft}from"./Ellipsoid-CuSwTtSS.js";import{a as Gt}from"./TiledImageSource-BrtEEhz2.js";class Ot{constructor(){this.creditsCount={}}_adjustAttributions(t,e){const n=this.creditsCount,o=t.split(/;/g);for(let c=0,f=o.length;c<f;c++){const P=o[c];P in n||(n[P]=0),n[P]+=e?1:-1,n[P]<=0&&delete n[P]}}addAttributions(t){this._adjustAttributions(t,!0)}removeAttributions(t){this._adjustAttributions(t,!1)}toString(){return Object.entries(this.creditsCount).sort((e,n)=>{const o=e[1];return n[1]-o}).map(e=>e[0]).join("; ")}}function bt(E){let t=null;return Pt(E,e=>{if(e.content&&e.content.uri){const[,n]=e.content.uri.split("?");return t=new URLSearchParams(n).get("session"),!0}return!1}),t}class Dt{constructor({apiToken:t,autoRefreshToken:e=!1,logoUrl:n=null,useRecommendedSettings:o=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.priority=-1/0,this.apiToken=t,this.autoRefreshToken=e,this.useRecommendedSettings=o,this.logoUrl=n,this.sessionToken=null,this.tiles=null,this._onLoadCallback=null,this._visibilityChangeCallback=null,this._tokenRefreshPromise=null,this._attributionsManager=new Ot,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(t){t!=null&&(t.resetFailedTiles(),t.rootURL==null&&(t.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),this.useRecommendedSettings&&(t.parseQueue.maxJobs=10,t.downloadQueue.maxJobs=30,t.errorTarget=20),this.tiles=t,this._onLoadCallback=({tileSet:e})=>{this.sessionToken=bt(e.root),t.removeEventListener("load-tile-set",this._onLoadCallback)},this._visibilityChangeCallback=({tile:e,visible:n})=>{const o=e.cached.metadata.asset.copyright||"";n?this._attributionsManager.addAttributions(o):this._attributionsManager.removeAttributions(o)},t.addEventListener("load-tile-set",this._onLoadCallback),t.addEventListener("tile-visibility-change",this._visibilityChangeCallback))}getAttributions(t){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,t.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),t.push(this._attribution))}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&(t.searchParams.append("key",this.apiToken),this.sessionToken!==null&&t.searchParams.append("session",this.sessionToken)),t.toString()}dispose(){const{tiles:t}=this;t.removeEventListener("load-tile-set",this._onLoadCallback),t.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(t,e){this._tokenRefreshPromise!==null&&(await this._tokenRefreshPromise,t=this.preprocessURL(t));const n=await fetch(t,e);return n.status>=400&&n.status<=499&&this.autoRefreshToken?(await this._refreshToken(e),fetch(this.preprocessURL(t),e)):n}_refreshToken(t){if(this._tokenRefreshPromise===null){const e=new URL(this.tiles.rootURL);e.searchParams.append("key",this.apiToken),this._tokenRefreshPromise=fetch(e,t).then(n=>n.json()).then(n=>{this.sessionToken=bt(n.root),this._tokenRefreshPromise=null}),this._tokenRefreshPromise.catch(n=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:n,url:e})})}return this._tokenRefreshPromise}}function dt(E){return E>>1^-(E&1)}class Ht extends zt{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const n=new DataView(t),o=()=>{const s=n.getFloat64(e,!0);return e+=8,s},c=()=>{const s=n.getFloat32(e,!0);return e+=4,s},f=()=>{const s=n.getUint32(e,!0);return e+=4,s},P=()=>{const s=n.getUint8(e);return e+=1,s},v=(s,r)=>{const u=new r(t,e,s);return e+=s*r.BYTES_PER_ELEMENT,u},C={center:[o(),o(),o()],minHeight:c(),maxHeight:c(),sphereCenter:[o(),o(),o()],sphereRadius:o(),horizonOcclusionPoint:[o(),o(),o()]},i=f(),x=v(i,Uint16Array),j=v(i,Uint16Array),p=v(i,Uint16Array),g=new Float32Array(i),L=new Float32Array(i),N=new Float32Array(i);let B=0,q=0,tt=0;const _=32767;for(let s=0;s<i;++s)B+=dt(x[s]),q+=dt(j[s]),tt+=dt(p[s]),g[s]=B/_,L[s]=q/_,N[s]=tt/_;const F=i>65536,G=F?Uint32Array:Uint16Array;F?e=Math.ceil(e/4)*4:e=Math.ceil(e/2)*2;const Y=f(),$=v(Y*3,G);let D=0;for(var Q=0;Q<$.length;++Q){const s=$[Q];$[Q]=D-s,s===0&&++D}const H=(s,r)=>L[r]-L[s],z=(s,r)=>-H(s,r),et=(s,r)=>g[s]-g[r],h=(s,r)=>-et(s,r),l=f(),U=v(l,G);U.sort(H);const I=f(),y=v(I,G);y.sort(et);const O=f(),X=v(O,G);X.sort(z);const T=f(),S=v(T,G);S.sort(h);const b={westIndices:U,southIndices:y,eastIndices:X,northIndices:S},A={};for(;e<n.byteLength;){const s=P(),r=f();if(s===1){const u=v(i*2,Uint8Array),w=new Float32Array(i*3);for(let R=0;R<i;R++){let a=u[2*R+0]/255*2-1,m=u[2*R+1]/255*2-1;const d=1-(Math.abs(a)+Math.abs(m));if(d<0){const V=a;a=(1-Math.abs(m))*vt(V),m=(1-Math.abs(V))*vt(m)}const k=Math.sqrt(a*a+m*m+d*d);w[3*R+0]=a/k,w[3*R+1]=m/k,w[3*R+2]=d/k}A.octvertexnormals={extensionId:s,normals:w}}else if(s===2){const u=r===1?1:256,w=v(u*u,Uint8Array);A.watermask={extensionId:s,mask:w,size:u}}else if(s===4){const u=f(),w=v(u,Uint8Array),R=new TextDecoder().decode(w);A.metadata={extensionId:s,json:JSON.parse(R)}}}return{header:C,indices:$,vertexData:{u:g,v:L,height:N},edgeIndices:b,extensions:A}}}function vt(E){return E<0?-1:1}const Lt=new J,ut=new pt,M=new J,nt=new J;class Xt extends Ht{constructor(t=St){super(),this.manager=t,this.ellipsoid=new Ft,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:n,skirtLength:o,smoothSkirtNormals:c,minLat:f,maxLat:P,minLon:v,maxLon:C}=this,{header:i,indices:x,vertexData:j,edgeIndices:p,extensions:g}=super.parse(t),L=new gt,N=new Et,B=new yt(L,N);B.position.set(...i.center);const q="octvertexnormals"in g,tt=j.u.length,_=[],F=[],G=[],Y=[];let $=0,D=0;for(let h=0;h<tt;h++)H(h,M),z(M.x,M.y,M.z,nt),F.push(M.x,M.y),_.push(...nt);for(let h=0,l=x.length;h<l;h++)G.push(x[h]);if(q){const h=g.octvertexnormals.normals;for(let l=0,U=h.length;l<U;l++)Y.push(h[l])}if(L.addGroup($,x.length,D),$+=x.length,D++,n){const h=_.length/3;for(let l=0;l<tt;l++)H(l,M),z(M.x,M.y,M.z,nt,-o),F.push(M.x,M.y),_.push(...nt);for(let l=x.length-1;l>=0;l--)G.push(x[l]+h);if(q){const l=g.octvertexnormals.normals;for(let U=0,I=l.length;U<I;U++)Y.push(-l[U])}L.addGroup($,x.length,D),$+=x.length,D++}if(o>0){const{westIndices:h,eastIndices:l,southIndices:U,northIndices:I}=p;let y;const O=et(h);y=_.length/3,F.push(...O.uv),_.push(...O.positions);for(let b=0,A=O.indices.length;b<A;b++)G.push(O.indices[b]+y);const X=et(l);y=_.length/3,F.push(...X.uv),_.push(...X.positions);for(let b=0,A=X.indices.length;b<A;b++)G.push(X.indices[b]+y);const T=et(U);y=_.length/3,F.push(...T.uv),_.push(...T.positions);for(let b=0,A=T.indices.length;b<A;b++)G.push(T.indices[b]+y);const S=et(I);y=_.length/3,F.push(...S.uv),_.push(...S.positions);for(let b=0,A=S.indices.length;b<A;b++)G.push(S.indices[b]+y);q&&(Y.push(...O.normals),Y.push(...X.normals),Y.push(...T.normals),Y.push(...S.normals)),L.addGroup($,x.length,D),$+=x.length,D++}for(let h=0,l=_.length;h<l;h+=3)_[h+0]-=i.center[0],_[h+1]-=i.center[1],_[h+2]-=i.center[2];const Q=_.length/3>65535?new Uint32Array(G):new Uint16Array(G);if(L.setIndex(new st(Q,1,!1)),L.setAttribute("position",new st(new Float32Array(_),3,!1)),L.setAttribute("uv",new st(new Float32Array(F),2,!1)),q&&L.setAttribute("normal",new st(new Float32Array(Y),3,!1)),"watermask"in g){const{mask:h,size:l}=g.watermask,U=new Uint8Array(2*l*l);for(let y=0,O=h.length;y<O;y++){const X=h[y]===255?0:255;U[2*y+0]=X,U[2*y+1]=X}const I=new Vt(U,l,l,Ct,Mt);I.flipY=!0,I.minFilter=Nt,I.magFilter=Bt,I.needsUpdate=!0,N.roughnessMap=I}return B.userData.minHeight=i.minHeight,B.userData.maxHeight=i.maxHeight,"metadata"in g&&(B.userData.metadata=g.metadata.json),B;function H(h,l){return l.x=j.u[h],l.y=j.v[h],l.z=j.height[h],l}function z(h,l,U,I,y=0){const O=it.lerp(i.minHeight,i.maxHeight,U),X=it.lerp(v,C,h),T=it.lerp(f,P,l);return e.getCartographicToPosition(T,X,O+y,I),I}function et(h){const l=[],U=[],I=[],y=[],O=[];for(let S=0,b=h.length;S<b;S++)H(h[S],M),l.push(M.x,M.y),I.push(M.x,M.y),z(M.x,M.y,M.z,nt),U.push(...nt),z(M.x,M.y,M.z,nt,-o),y.push(...nt);const X=h.length-1;for(let S=0;S<X;S++){const b=S,A=S+1,s=S+h.length,r=S+h.length+1;O.push(b,s,A),O.push(A,s,r)}let T=null;if(q){const S=(U.length+y.length)/3;if(c){T=new Array(S*3);const b=g.octvertexnormals.normals,A=T.length/2;for(let s=0,r=S/2;s<r;s++){const u=h[s],w=3*s,R=b[3*u+0],a=b[3*u+1],m=b[3*u+2];T[w+0]=R,T[w+1]=a,T[w+2]=m,T[A+w+0]=R,T[A+w+1]=a,T[A+w+2]=m}}else{T=[],ut.a.fromArray(U,0),ut.b.fromArray(y,0),ut.c.fromArray(U,3),ut.getNormal(Lt);for(let b=0;b<S;b++)T.push(...Lt)}}return{uv:[...l,...I],positions:[...U,...y],indices:O,normals:T}}}clipToQuadrant(t,e,n){const o=new J,c=new J,f=new J,P=new J,v=new J,C=new J,i=new J,x=new J,j={},p=.5,g=new jt,L=["a","b","c"],{ellipsoid:N,skirtLength:B,solid:q,smoothSkirtNormals:tt}=this,_=t.geometry,F=_.attributes.normal,G=_.index;let Y=0;const $={},D=[],Q=F?[]:null,H=[],z=[],et=e?0:-.5,h=n?0:-.5,l=new gt,U=_.groups[0];let I=z.length,y=0;for(let s=U.start/3;s<(U.start+U.count)/3;s++){const r=G.getX(s*3+0),u=G.getX(s*3+1),w=G.getX(s*3+2),R=g.get();R.setFromAttributeAndIndices(_,r,u,w);const a=[];S(R,"x",e,a);const m=[];for(let K=0,ot=a.length;K<ot;K++)S(a[K],"y",n,m);const{minLat:d,maxLat:k,minLon:V,maxLon:lt,ellipsoid:Z}=this;for(let K=0,ot=m.length;K<ot;K++){const W=m[K];L.forEach(ft=>{const ct=W.uv[ft];if(ct.x!==p&&ct.y!==p)return;const ht=W.position[ft],Tt=it.lerp(d,k,ct.y),kt=it.lerp(V,lt,ct.x);ht.add(t.position),Z.getPositionToCartographic(ht,j),Z.getCartographicToPosition(Tt,kt,j.height,ht),ht.sub(t.position)}),A(W.position.a,W.uv.a,W.normal.a),A(W.position.b,W.uv.b,W.normal.b),A(W.position.c,W.uv.c,W.normal.c)}g.reset()}l.addGroup(I,z.length-I,y),y++;const O=z.length/3;if(q){I=z.length;for(let s=O*3-1;s>=0;s--){const r=z[s];i.fromArray(D,r*3).add(t.position),N.getPositionToNormal(i,i),f.fromArray(D,r*3).addScaledVector(i,-B),o.fromArray(H,r*2),i.fromArray(Q,r*3),A(f,o,i)}l.addGroup(I,z.length-I,y),y++}if(B>0){I=z.length;for(let s=0;s<O;s++){const r=3*s;for(let u=0;u<3;u++){const w=(u+1)%3,R=z[r+u],a=z[r+w];if(o.fromArray(H,R*2),c.fromArray(H,a*2),o.x===c.x&&(o.x===0||o.x===p||o.x===1)||o.y===c.y&&(o.y===0||o.y===p||o.y===1)){f.fromArray(D,R*3),P.fromArray(D,a*3);const m=f,d=P,k=v.copy(f),V=C.copy(P);i.copy(k).add(t.position),N.getPositionToNormal(i,i),k.addScaledVector(i,-B),i.copy(V).add(t.position),N.getPositionToNormal(i,i),V.addScaledVector(i,-B),tt&&Q?(i.fromArray(Q,R*3),x.fromArray(Q,a*3)):(i.subVectors(m,d),x.subVectors(m,k).cross(i).normalize(),i.copy(x)),A(d,c,x),A(m,o,i),A(k,o,i),A(d,c,x),A(k,o,i),A(V,c,x)}}}l.addGroup(I,z.length-I,y),y++}for(let s=0,r=H.length;s<r;s+=2)H[s]=(H[s]+et)*2,H[s+1]=(H[s+1]+h)*2;const X=D.length/3>65535?new Uint32Array(z):new Uint16Array(z);l.setIndex(new st(X,1,!1)),l.setAttribute("position",new st(new Float32Array(D),3,!1)),l.setAttribute("uv",new st(new Float32Array(H),2,!1)),F&&l.setAttribute("normal",new st(new Float32Array(Q),3,!1));const T=new yt(l,t.material.clone());return T.position.copy(t.position),T.quaternion.copy(t.quaternion),T.scale.copy(t.scale),T.userData.minHeight=t.userData.minHeight,T.userData.maxHeight=t.userData.maxHeight,T;function S(s,r,u,w){const R=[],a=[],m=[];for(let d=0;d<3;d++){const k=L[d],V=L[(d+1)%3],lt=s.uv[k],Z=s.uv[V],K=lt[r],ot=Z[r];(K<p!=ot<p||K===p)&&(R.push(d),a.push([k,V]),m.push(it.mapLinear(p,K,ot,0,1)))}if(R.length!==2)Math.min(s.uv.a[r],s.uv.b[r],s.uv.c[r])<p===u&&w.push(s);else if(R.length===2){const d=g.get(),k=g.get(),V=g.get();(R[0]+1)%3===R[1]?(d.lerpVertex(s,a[0][0],a[0][1],m[0],"a"),d.copyVertex(s,a[0][1],"b"),d.lerpVertex(s,a[1][0],a[1][1],m[1],"c"),d.uv.a[r]=p,d.uv.c[r]=p,k.lerpVertex(s,a[0][0],a[0][1],m[0],"a"),k.copyVertex(s,a[1][1],"b"),k.copyVertex(s,a[0][0],"c"),k.uv.a[r]=p,V.lerpVertex(s,a[0][0],a[0][1],m[0],"a"),V.lerpVertex(s,a[1][0],a[1][1],m[1],"b"),V.copyVertex(s,a[1][1],"c"),V.uv.a[r]=p,V.uv.b[r]=p):(d.lerpVertex(s,a[0][0],a[0][1],m[0],"a"),d.lerpVertex(s,a[1][0],a[1][1],m[1],"b"),d.copyVertex(s,a[0][0],"c"),d.uv.a[r]=p,d.uv.b[r]=p,k.lerpVertex(s,a[0][0],a[0][1],m[0],"a"),k.copyVertex(s,a[0][1],"b"),k.lerpVertex(s,a[1][0],a[1][1],m[1],"c"),k.uv.a[r]=p,k.uv.c[r]=p,V.copyVertex(s,a[0][1],"a"),V.copyVertex(s,a[1][0],"b"),V.lerpVertex(s,a[1][0],a[1][1],m[1],"c"),V.uv.c[r]=p);let Z;Z=Math.min(d.uv.a[r],d.uv.b[r],d.uv.c[r]),Z<p===u&&w.push(d),Z=Math.min(k.uv.a[r],k.uv.b[r],k.uv.c[r]),Z<p===u&&w.push(k),Z=Math.min(V.uv.a[r],V.uv.b[r],V.uv.c[r]),Z<p===u&&w.push(V)}}function b(s,r,u){const a=~~(s*1e5+.5),m=~~(r*1e5+.5),d=~~(u*1e5+.5);return`${a}_${m}_${d}`}function A(s,r,u){let w=b(s.x,s.y,s.z);Q&&(w+=`_${b(u.x,u.y,u.z)}`),w in $||($[w]=Y,Y++,D.push(s.x,s.y,s.z),H.push(r.x,r.y),Q&&Q.push(u.x,u.y,u.z));const R=$[w];return z.push(R),R}}}class jt{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const e=new qt;this.pool.push(e)}const t=this.pool[this.index];return this.index++,t}reset(){this.index=0}}class qt{constructor(){this.position=new pt,this.uv=new pt,this.normal=new pt}setFromAttributeAndIndices(t,e,n,o){this.position.setFromAttributeAndIndices(t.attributes.position,e,n,o),this.uv.setFromAttributeAndIndices(t.attributes.uv,e,n,o),t.attributes.normal&&this.normal.setFromAttributeAndIndices(t.attributes.normal,e,n,o)}lerpVertex(t,e,n,o,c){this.position[c].lerpVectors(t.position[e],t.position[n],o),this.uv[c].lerpVectors(t.uv[e],t.uv[n],o),this.normal[c].lerpVectors(t.normal[e],t.normal[n],o)}copyVertex(t,e,n){this.position[n].copy(t.position[e]),this.uv[n].copy(t.uv[e]),this.normal[n].copy(t.normal[e])}}const _t=Symbol("TILE_X"),At=Symbol("TILE_Y"),at=Symbol("TILE_LEVEL"),rt=Symbol("TILE_AVAILABLE"),wt=1e4,xt=new J;function $t(E,t,e,n){if(t<E.length){const o=E[t];for(let c=0,f=o.length;c<f;c++){const{startX:P,startY:v,endX:C,endY:i}=o[c];if(e>=P&&e<=C&&n>=v&&n<=i)return!0}}return!1}function Rt(E){const{available:t=null,maxzoom:e=null}=E;return e===null?t.length:e}function Qt(E){const{metadataAvailability:t=-1}=E;return t}function mt(E,t){const e=E[at],n=Qt(t),o=Rt(t);return e<o&&n!==-1&&e%n===0}function Yt(E,t,e,n,o){return o.tiles[0].replace(/{\s*z\s*}/g,e).replace(/{\s*x\s*}/g,E).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,n)}class Jt{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:n=null,smoothSkirtNormals:o=!0,solid:c=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=n,this.smoothSkirtNormals=o,this.solid=c,this.attribution=null,this.tiling=new Gt,this.projection=new Ut}init(t){t.fetchOptions.header=t.fetchOptions.header||{},t.fetchOptions.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileSet(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(n=>e=n.preprocessURL?n.preprocessURL(e,null):e),t.invokeOnePlugin(n=>n.fetchData&&n.fetchData(e,this.tiles.fetchOptions)).then(n=>n.json()).then(n=>{this.layer=n;const{projection:o="EPSG:4326",extensions:c=[],attribution:f="",available:P=null}=n,{tiling:v,tiles:C,projection:i}=this;f&&(this.attribution={value:f,type:"string",collapsible:!0}),c.length>0&&(C.fetchOptions.header.Accept+=`;extensions=${c.join("-")}`),i.setScheme(o);const{tileCountX:x,tileCountY:j}=i;v.setProjection(i),v.generateLevels(Rt(n),x,j);const p=[];for(let N=0;N<x;N++){const B=this.createChild(0,N,0,P);B&&p.push(B)}const g={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getFullBounds(),-1e4,wt]},children:p,[rt]:P,[at]:-1}};let L=C.rootURL;return C.invokeAllPlugins(N=>L=N.preprocessURL?N.preprocessURL(L,null):L),C.preprocessTileSet(g,L),g})}async parseToMesh(t,e,n,o){const{skirtLength:c,solid:f,smoothSkirtNormals:P,tiles:v}=this,C=v.ellipsoid,i=new Xt(v.manager);i.ellipsoid.copy(C),i.solid=f,i.smoothSkirtNormals=P,i.skirtLength=c===null?e.geometricError:c;let x;if(n==="tile_split"){const L=new URL(o).searchParams,N=L.get("left")==="true",B=L.get("bottom")==="true",[q,tt,_,F]=e.parent.boundingVolume.region;i.minLat=tt,i.maxLat=F,i.minLon=q,i.maxLon=_,x=i.clipToQuadrant(e.parent.cached.scene,N,B)}else{const[L,N,B,q]=e.boundingVolume.region;i.minLat=N,i.maxLat=q,i.minLon=L,i.maxLon=B,x=i.parse(t)}const{minHeight:j,maxHeight:p,metadata:g}=x.userData;return e.boundingVolume.region[4]=j,e.boundingVolume.region[5]=p,e.cached.boundingVolume.setRegionData(C,...e.boundingVolume.region),g&&("geometricerror"in g&&(e.geometricError=g.geometricerror),mt(e,this.layer)&&"available"in g&&e.children.length===0&&(e[rt]=[...new Array(e[at]+1).fill(null),...g.available])),this.expandChildren(e),x}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,n,o){const{tiles:c,layer:f,tiling:P,projection:v}=this,C=c.ellipsoid,i=o===null||$t(o,t,e,n),x=Yt(e,n,t,1,f),j=[...P.getTileBounds(e,n,t),-1e4,wt],[,p,,g,,L]=j,N=p>0!=g>0?0:Math.min(Math.abs(p),Math.abs(g));C.getCartographicToPosition(N,0,L,xt),xt.z=0;const B=v.tileCountX,_=Math.max(...C.radius)*2*Math.PI*.25/(65*B)/2**t,F={[rt]:null,[at]:t,[_t]:e,[At]:n,refine:"REPLACE",geometricError:_,boundingVolume:{region:j},content:i?{uri:x}:null,children:[]};return mt(F,f)||(F[rt]=o),F}expandChildren(t){t.children.length=0,t.__childrenProcessed=0;const e=t[at],n=t[_t],o=t[At],c=t[rt];let f=!1;for(let P=0;P<2;P++)for(let v=0;v<2;v++){const C=this.createChild(e+1,2*n+P,2*o+v,c);C.content!==null?(t.children.push(C),f=!0):(t.children.push(C),C.content={uri:`tile.tile_split?bottom=${v===0}&left=${P===0}`})}f||(t.children.length=0)}fetchData(t,e){if(/tile_split/.test(t))return null}disposeTile(t){mt(t,this.layer)&&(t.children.length=0,t.__childrenProcessed=0,t[rt]=null),t.children.length=0,t.__childrenProcessed=0}}class ne{constructor({apiToken:t,assetId:e=null,autoRefreshToken:n=!1,useRecommendedSettings:o=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.priority=-1/0,this.apiToken=t,this.assetId=e,this.autoRefreshToken=n,this.useRecommendedSettings=o,this.tiles=null,this.endpointURL=null,this._bearerToken=null,this._tileSetVersion=-1,this._tokenRefreshPromise=null,this._attributions=[],this._disposed=!1}init(t){this.assetId!==null&&(t.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=t,this.endpointURL=t.rootURL,t.resetFailedTiles()}loadRootTileSet(){return this._refreshToken().then(()=>this.tiles.invokeOnePlugin(t=>t!==this&&t.loadRootTileSet&&t.loadRootTileSet()))}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&this._tileSetVersion!=-1&&t.searchParams.append("v",this._tileSetVersion),t.toString()}fetchData(t,e){return this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")!==null?null:Promise.resolve().then(async()=>{this._tokenRefreshPromise!==null&&(await this._tokenRefreshPromise,t=this.preprocessURL(t));const o=await fetch(t,e);return o.status>=400&&o.status<=499&&this.autoRefreshToken?(await this._refreshToken(e),fetch(this.preprocessURL(t),e)):o})}getAttributions(t){this.tiles.visibleTiles.size>0&&t.push(...this._attributions)}_refreshToken(t){if(this._tokenRefreshPromise===null){const e=new URL(this.endpointURL);e.searchParams.append("access_token",this.apiToken),this._tokenRefreshPromise=fetch(e,t).then(n=>{if(this._disposed)return null;if(!n.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${n.status}`);return n.json()}).then(n=>{if(this._disposed)return null;const o=this.tiles;if("externalType"in n){const c=new URL(n.options.url);o.rootURL=n.options.url,o.registerPlugin(new Dt({apiToken:c.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{if(n.type==="TERRAIN"&&o.getPluginByName("QUANTIZED_MESH_PLUGIN")===null?o.registerPlugin(new Jt({useRecommendedSettings:this.useRecommendedSettings})):n.type==="IMAGERY"&&o.getPluginByName("TMS_TILES_PLUGIN")===null&&o.registerPlugin(new It({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),o.rootURL=n.url,o.fetchOptions.headers=o.fetchOptions.headers||{},o.fetchOptions.headers.Authorization=`Bearer ${n.accessToken}`,e.searchParams.has("v")&&this._tileSetVersion===-1){const c=new URL(n.url);this._tileSetVersion=c.searchParams.get("v")}this._bearerToken=n.accessToken,n.attributions&&(this._attributions=n.attributions.map(c=>({value:c.html,type:"html",collapsible:c.collapsible})))}return this._tokenRefreshPromise=null,n}),this._tokenRefreshPromise.catch(n=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:n,url:e})})}return this._tokenRefreshPromise}dispose(){this._disposed=!0}}export{ne as C};
