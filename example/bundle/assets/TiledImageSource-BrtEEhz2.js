import{g as C,bc as y,q as E,aJ as I,y as b}from"./three.module-Cdr6prlM.js";const L=Symbol("TILE_X"),v=Symbol("TILE_Y"),x=Symbol("TILE_LEVEL");class w{get tiling(){return this.imageSource.tiling}constructor(e={}){const{pixelSize:t=.01,center:i=!1,useRecommendedSettings:o=!0,imageSource:n=null}=e;this.priority=-10,this.tiles=null,this.imageSource=n,this.pixelSize=t,this.center=i,this.useRecommendedSettings=o}init(e){this.useRecommendedSettings&&(e.errorTarget=1),this.tiles=e,this.imageSource.fetchOptions=e.fetchOptions,this.imageSource.fetchData=(t,i)=>(e.invokeAllPlugins(o=>t=o.preprocessURL?o.preprocessURL(t,null):t),e.invokeOnePlugin(o=>o!==this&&o.fetchData&&o.fetchData(t,i)))}async loadRootTileSet(){const{tiles:e,imageSource:t}=this;let i=e.rootURL;return e.invokeAllPlugins(o=>i=o.preprocessURL?o.preprocessURL(i,null):i),await t.init(i),this.getTileset(i)}async parseToMesh(e,t,i,o,n){const s=t[L],r=t[v],c=t[x],l=await this.imageSource.processBuffer(e);this.imageSource.setData(s,r,c,l);let h=1,u=1,g=0,a=0,p=0;const m=t.boundingVolume.box;m&&([g,a,p]=m,h=m[3],u=m[7]);const d=new C(new y(2*h,2*u),new E({map:l,transparent:!0}));return d.position.set(g,a,p),d}preprocessNode(e){const{tiling:t}=this,i=t.maxLevel;e[x]<i&&e.parent!==null&&this.expandChildren(e)}disposeTile(e){const t=e[L],i=e[v],o=e[x];this.imageSource.release(t,i,o)}getTileset(e){const{tiling:t,tiles:i}=this,o=t.minLevel,{tileCountX:n,tileCountY:s}=t.getLevel(o),r=[];for(let l=0;l<n;l++)for(let h=0;h<s;h++){const u=this.createChild(l,h,o);u!==null&&r.push(u)}const c={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:r,[x]:-1,[L]:0,[v]:0}};return i.preprocessTileSet(c,e),c}getUrl(e,t,i){return this.imageSource.getUrl(e,t,i)}createBoundingVolume(e,t,i){const{center:o,pixelSize:n,tiling:s}=this,{pixelWidth:r,pixelHeight:c}=s.getLevel(s.maxLevel),[l,h,u,g]=i===-1?s.getFullBounds(!0):s.getTileBounds(e,t,i,!0);let a=(u-l)/2,p=(g-h)/2,m=l+a,d=h+p;return o&&(m-=.5,d-=.5),m*=r*n,a*=r*n,d*=c*n,p*=c*n,{box:[m,d,0,a,0,0,0,p,0,0,0,0]}}createChild(e,t,i){const{pixelSize:o,tiling:n}=this;if(!n.getTileExists(e,t,i))return null;const{pixelWidth:s,pixelHeight:r}=n.getLevel(n.maxLevel),{pixelWidth:c,pixelHeight:l}=n.getLevel(i);return{refine:"REPLACE",geometricError:o*(Math.max(s/c,r/l)-1),boundingVolume:this.createBoundingVolume(e,t,i),content:{uri:this.getUrl(e,t,i)},children:[],[L]:e,[v]:t,[x]:i}}expandChildren(e){const t=e[x],i=e[L],o=e[v];for(let n=0;n<2;n++)for(let s=0;s<2;s++){const r=this.createChild(2*i+n,2*o+s,t+1);r&&e.children.push(r)}}}function T(...f){return f.join("_")}class j{constructor(){this.cache={}}fetchItem(){}disposeItem(){}setData(...e){const{cache:t}=this,i=e.pop(),o=T(...e);if(o in t)throw new Error(`DataCache: "${o}" is already present.`);return this.cache[o]={abortController:new AbortController,result:i,count:1},i}lock(...e){const{cache:t}=this,i=T(...e);if(i in t)t[i].count++;else{const o=new AbortController,n={abortController:o,result:null,count:1};n.result=this.fetchItem(...e,o.signal).then(s=>(n.result=s,s)),this.cache[i]=n}return t[i].result}release(...e){const{cache:t}=this,i=T(...e);if(i in t){const o=t[i];if(o.count--,o.count===0){const{result:n,abortController:s}=o;s.abort(),n instanceof Promise?n.then(r=>this.disposeItem(r)).catch(()=>{}):this.disposeItem(n),delete t[i]}return!0}return!1}get(...e){const{cache:t}=this,i=T(...e);return i in t?t[i].result:null}dispose(){const{cache:e}=this;for(const t in e){const{abortController:i,result:o}=e[t];i.abort(),o instanceof Promise?o.then(n=>this.disposeItem(n)).catch(()=>{}):this.disposeItem(o)}this.cache={}}}function P(f,e,t){return Math.min(Math.max(f,e),t)}class M{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const e=this._levels;for(let t=0;t<e.length;t++)if(e[t]!==null)return t;return-1}get rootBounds(){var e;return this._rootBounds??((e=this.projection)==null?void 0:e.getBounds())??[0,0,1,1]}get rootOrigin(){const e=this.rootBounds;return this._rootOrigin??[e[0],e[1]]}constructor(){this.flipY=!1,this.pixelOverlap=0,this._rootBounds=null,this._rootOrigin=null,this.projection=null,this._levels=[]}setLevel(e,t={}){const i=this._levels;for(;i.length<e;)i.push(null);const{tilePixelWidth:o=256,tilePixelHeight:n=256,tileCountX:s=2**e,tileCountY:r=2**e}=t,{pixelWidth:c=o*s,pixelHeight:l=n*r}=t;i[e]={tilePixelWidth:o,tilePixelHeight:n,pixelWidth:c,pixelHeight:l,tileCountX:s,tileCountY:r}}generateLevels(e,t,i,o={}){const{minLevel:n=0,tilePixelWidth:s=256,tilePixelHeight:r=256}=o,c=e-1,{pixelWidth:l=s*t*2**c,pixelHeight:h=r*i*2**c}=o;for(let u=n;u<e;u++){const g=e-u-1,a=Math.ceil(l*2**-g),p=Math.ceil(h*2**-g),m=Math.ceil(a/s),d=Math.ceil(p/r);this.setLevel(u,{tilePixelWidth:s,tilePixelHeight:r,pixelWidth:a,pixelHeight:p,tileCountX:m,tileCountY:d})}}getLevel(e){return this._levels[e]}setOrigin(e,t){this._rootOrigin=[e,t]}setBounds(e,t,i,o){this._rootBounds=[e,t,i,o]}setProjection(e){this.projection=e}getTileAtPoint(e,t,i,o=!1,n=!0){const{projection:s,flipY:r}=this,{tileCountX:c,tileCountY:l}=this.getLevel(i),h=1/c,u=1/l;s&&!o&&(e=s.convertLongitudeToProjection(e),t=s.convertLatitudeToProjection(t)),n&&(e=P(e,0,1),t=P(t,0,1));let g=Math.floor(e/h),a=Math.floor(t/u);return r&&(a=l-1-a),n&&(g=P(g,0,c-1),a=P(a,0,l-1)),[g,a]}getTilesInRange(e,t,i,o,n,s=!1,r=!0){const c=this.getTileAtPoint(e,t,n,s,r),l=this.getTileAtPoint(i,o,n,s,r);return this.flipY&&([c[1],l[1]]=[l[1],c[1]]),[...c,...l]}getTileExists(e,t,i,o){const[n,s,r,c]=this.rootBounds,[l,h,u,g]=this.getTileBounds(e,t,i,o);return!(l>=u||h>=g)&&l<=r&&h<=c&&u>=n&&g>=s}getFullBounds(e=!1){const{projection:t}=this,i=[...this.rootBounds];return t&&e&&(i[0]=t.convertLongitudeToProjection(i[0]),i[1]=t.convertLatitudeToProjection(i[1]),i[2]=t.convertLongitudeToProjection(i[2]),i[3]=t.convertLatitudeToProjection(i[3])),i}getTileBounds(e,t,i,o=!1){const{flipY:n,pixelOverlap:s,projection:r}=this,{tilePixelWidth:c,tilePixelHeight:l,pixelWidth:h,pixelHeight:u}=this.getLevel(i);let g=c*e-s,a=l*t-s,p=g+c+s*2,m=a+l+s*2;if(g=Math.max(g,0),a=Math.max(a,0),p=Math.min(p,h),m=Math.min(m,u),g=g/h,p=p/h,a=a/u,m=m/u,n){const S=(m-a)/2,B=1-(a+m)/2;a=B-S,m=B+S}const d=[g,a,p,m];return r&&!o&&(d[0]=r.convertProjectionToLongitude(d[0]),d[1]=r.convertProjectionToLatitude(d[1]),d[2]=r.convertProjectionToLongitude(d[2]),d[3]=r.convertProjectionToLatitude(d[3])),d}}class R extends j{constructor(){super(),this.tiling=new M,this.fetchOptions={},this.fetchData=(...e)=>fetch(...e)}init(e){}async processBufferToTexture(e){const t=new Blob([e]),i=await createImageBitmap(t,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),o=new I(i);return o.generateMipmaps=!1,o.colorSpace=b,o.needsUpdate=!0,o}fetchItem(...e){const t=this.getUrl(...e);return this.fetchData(t,this.fetchOptions).then(i=>i.arrayBuffer()).then(i=>this.processBufferToTexture(i))}disposeItem(e){e.dispose(),e.image instanceof ImageBitmap&&e.image.close()}getUrl(...e){}}export{w as I,R as T,M as a,x as b,L as c,v as d};
